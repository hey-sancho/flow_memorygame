import lib/tropic/tropic_ui;

Card(
	face: TColor,
	opened: DynamicBehaviour<bool>,
	solved: DynamicBehaviour<bool>,
);

COLORS = [
	TGreen(),
	TRed(),
	TBlue(),
	TYellow(),
	TWhite(),
	TBlack(),
];

MATCH = 2; // number of cards to match
COLS = 4;

FACES = {
	colorsLen = length(COLORS);
	generate(0, colorsLen * MATCH, \i -> COLORS[i % colorsLen]);
}

drawCard(card: Card) -> Tropic {
	size = TFixed(150.0, 150.0);

	open = \ -> nextDistinct(card.opened, true);
	state = [TOnClicked(open), TEnabled(fnot(card.solved))];

	button = TSelect(card.opened, \opened -> {
		faceColor = if (opened) card.face else TDarkGrey();
		TTextButton("", "", [faceColor, TForeground(size)], state);
	});

	TBorder4(2.0, button);
}

blockerForm(content: Tropic, click: DynamicBehaviour<bool>, visible: Transform<bool>) -> Tropic {
	state = [
		// send click signals to behaviour
		TMouseDown(click),
		// disallow event propagation below
		MouseMove(\mi -> mi().inside),
		RollOver(nop1),
		RollOut(nop1)
	];

	TCopySize(
		TFrame(40.0, 0.0, [Fill(0xe3e3e3)], content),
		\tr -> TVisible(visible, TInteractive(state, TRectangle(interactiveRectangleStyle, tr))),
		true
	);
}

main() {
	header = TText("Memory game", [FontSize(20.0)]);

	makeCard = \color -> Card(color, make(false), make(false));
	cards = map(shuffleArray(FACES), makeCard);
	cardGrid = TGrid(splitByNumber(map(cards, drawCard), COLS));

	activeCardStates = fmerge(map(cards, \c -> fand(c.opened, fnot(c.solved))));
	activeCount = flength(ffilter(activeCardStates, idfn));

	closeClick = make(false);
	closeOpened = \close -> {
		if (close) {
			unsolvedCards = filter(cards, \c -> !getValue(c.solved));
			// deferred pauses execution for a bit, to avoid bad update cycles
			deferred(\ -> iter(unsolvedCards, \c -> nextDistinct(c.opened, false)));
		}
	}

	matchOpened = \activeStates -> {
		activeCards : [Card] = filtermapi(cards, \i, c -> if (activeStates[i]) Some(c) else None());
		if (length(activeCards) == MATCH) {
			face = activeCards[0].face; // if you need array indices, something is wrong
			matchedCards = filter(activeCards, \c : Card -> c.face == face);
			if (length(matchedCards) == MATCH) {
				deferred(\ -> iter(matchedCards, \c -> nextDistinct(c.solved, true)))
			}
		}
	}


	game = TConstruct(
		[
			makeSubscribe(activeCardStates, matchOpened),
			makeSubscribe(closeClick, closeOpened)
		],
		TLinesXCenter([
			header,
			blockerForm(cardGrid, closeClick, feq(activeCount, MATCH)),
		]) |> TCenterX
	);

	trender(game, []);
}
